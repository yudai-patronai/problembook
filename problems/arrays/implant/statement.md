---
id: 42003ac2-ff71-49f3-b505-b31d13b9b072
longname: Мур берсерк (вер. 3) Эпическое Сила 12
languages: [cpp]
tags: [arrays]
checker: cmp_file_nospace
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
source_header: header.cpp
source_footer: footer.cpp
---

Электромагнитный импульс поджарил часть управления вашего киберимпланта. Вам нужно быстро восстановить функцию распознавания.

Управление киберимплантом происходит через буфер, большая часть которого содержит шум, фон и мусорные данные. Чтобы понять, какие команды были посланы на киберимплант, из этого шума нужно выделить определенные последовательности значений. Вам нужно написать функцию, которая будет искать эти последовательности.

Прототип требуемой функции:
<pre>
void recognize(int* data_start, int* data_end, int* command, int** frame);
</pre>

### Аргументы

Четыре указателя:

- data_start – начало массива, в котором лежит буфер;
- data_end – конец массива, указатель на ячейку памяти, которая находится сразу **ПОСЛЕ** последнего элемента; *Такой способ может показаться странным, но на практике он очень удобен, поэтому применяется в контейнерах и алгоритмах STL, про которые мы будем говорить в следующем году.*
- command – указатель на целое число, по которому нужно положить код распознанной команды;
- frame – указатель на указатель, по которому нужно положить адрес элемента массива, в котором начинается первая распознанная команда.

Команд всего четыре. Они задаются глобальными константными массивами целых чисел длиной N. Названия массивов и коды команд смотрите в коде инфраструктуры, чуть ниже в тексте. Функция должна пройти по массиву от начала до конца и найти первое совпадение – N чисел подряд, которые совпадают с одной из команд. Результат своей работы она возвращает через два указателя, command и frame.

Если ни одной команды не нашлось, через command вернуть 0. Идейно верно было бы также вернуть nullptr через frame, но проверяющий код это проверять не будет.

В рамках данной задачи гарантируется, что вам будут переданы корректные указатели, делать проверки и очищать память не требуется.

### Инфраструктура (код, который можно использовать при отладке)

<pre>
#include &lt;iostream&gt;
using std::cout;
using std::endl;

const unsigned int N = 5;
const int left[N]  = {5, 4, 3, 2, 1}; // command code 1
const int right[N] = {1, 2, 3, 4, 5}; // command code 2
const int back[N]  = {1, 1, 1, 1, 1}; // command code 3
const int meow[N]  = {3, 2, 3, 2, 5}; // command code 4

void recognize(int* data_start, int* data_end, int* command, int** frame);
// Здесь ваша реализация функции. Можете писать свои вспомогательные функции, только не забудьте их тоже отправить.

int main()
{
    const int L = 21;
    int mindstream[L] = {3, 2, 3, 2, 5, 2, 3, 8, 3, 2, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5};
    int command = -1;
    int* frame = mindstream;
    int* end = mindstream + L;
    while (command)
    {
        recognize(frame, end, &amp;command, &amp;frame);
        if (!command) break;
        switch(command)
        {
            case 1:
                cout &lt;&lt; "left ";
                break;
            case 2:
                cout &lt;&lt; "right ";
                break;
            case 3:
                cout &lt;&lt; "back ";
                break;
            case 4:
                cout &lt;&lt; "MEOOOOW ";
                break;
        }
        frame += N;
    }
    cout &lt;&lt; endl;
    return 0;
}
</pre>

Если вы правильно напишете функцию распознавания, то этот код выведет на экран "MEOOOOW back right".

*Пишите самый простой вариант. Если бы у вас было время всего мира, вы бы могли придумать что-то хитрое, замороченное, распараллеленное и быстро работающее. Но сейчас нужно быстро и грубо. Просыпайся, самурай!*

**Внимание!** Сдавать нужно реализацию функции recognize и, если вы писали свои вспомогательные, то их тоже. Функцию main и глобальные массивы сдавать не нужно. Выводить что-либо на экран не нужно.

**И снова внимание!** При проверке, разумеется, будет другой проверяющий код и больше тестов. Не удивляйтесь и при необходимости читайте вывод проверяющего кода. Размеры глобальных массивов (значение константы N) и их содержимое будут другими. Количество массивов (четыре) и их названия (left, right, back, meow) будут те же.
