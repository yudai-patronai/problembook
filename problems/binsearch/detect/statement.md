---
id: fc226682-eb45-4f4e-af5e-0f364b2e541c
longname: Детектор Предтеч
languages: [cpp]
tags: [binsearch]
checker: cmp_long_long_seq
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
source_header: header.cpp
source_footer: footer.cpp
---
Детектор гравитационных волн измеряет поток частиц в различных направлениях. Вам нужно найти максимум. Связь с прибором осуществляется через вызов глобальной функции:
<pre>
uint32_t get_results(uint32_t channel);
</pre>
, где channel - это номер канала направления (от 0 до 359), а сама функция возвращает количество гравитонов, пойманных за интересующий нас промежуток времени.

Известно, что распределение выглядит примерно следующим образом:

**!!! ВСТАВИТЬ СЮДА КАРТИНКУ !!!**

У него есть ровно один минимум и ровно один максимум. От минимума до максимума оно монотонно возрастает (мы считаем, что область определения закольцована, и после 359-го канала идет 0-й), а от максимума до минимума монотонно убывает. 

Также известно, что после 25 вызовов связь с прибором прекратится. Придумайте что-нибудь похитрее, чем полный перебор. *Очевидно, что детектор с такой точностью - это артефакт палеоконтакта, и на нем большими красными цифрами идет отсчет до самоуничтожения.*

Вам нужно реализовать функцию detect, которая будет выводить максимальное количество гравитонов и канал направления, где они были зарегистрированы. Прототип этой функции:
<pre>
void detect();
</pre>

### Формат входных данных

Входных данных нет.

### Формат выходных данных

Два целых числа - максимальное количество гравитонов и номер соответствующего канала.

Для отладки можете использовать следующую реализацию. С ней ваш код должен выводить 255760 250. Не привязывайтесь к конкретным цифрам, при проверке на сервере функция будет другой. 

<pre>
uint32_t get_results(uint32_t channel)
{
    static uint32_t calls = 0;
    calls++;
    if (calls &gt; 25) return static_cast&lt;uint32_t&gt;(-1);

    static uint32_t min = 10, max = 255760;
    static uint32_t min_channel = 50, max_channel = 250;
    static uint32_t zero = 100000;

    if (channel &lt;= min_channel)
        return static_cast&lt;uint32_t&gt;(zero - channel*((double)zero - min)/min_channel);
    if (channel &lt;= max_channel)
        return static_cast&lt;uint32_t&gt;(min + ((double)channel - min_channel)*((double)max - min)/((double)max_channel - min_channel));
    if (channel &lt;= 360)
        return static_cast&lt;uint32_t&gt;(max - ((double)channel - max_channel)*((double)max - zero)/((double)360 - max_channel));
    return static_cast&lt;uint32_t&gt;(-1);
}

int main() {
    detect();
    return 0;
}
</pre>

**Внимание!** Сдавать нужно реализацию функции detect и подключаемые библиотеки (include). Функцию get_results сдавать не нужно, она будет приклеена к вашей программе перед проверкой.

**Внимание еще раз!** При проверке, разумеется, будет другая функция get_results. Не удивляйтесь и при необходимости читайте вывод проверяющего кода.

**И снова внимание! (Последний раз, честно.)** Это последняя задача - предположительно, на 10 баллов. Все посылки по этой задаче будут прочитаны глазами человеков. Поэтому комментарии, поясняющие ход мыслей, очень приветствуются. Можно отправлять не до конца работающий код, если в нем заложена хорошая идея. Алгоритмы, позволяющие сократить количество запросов, будут отмечены отдельно.

Спасибо за внимание.
