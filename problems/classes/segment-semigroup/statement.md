---
id: f8575c61-4cbc-4607-b916-e32702b452bf
longname: Полугруппа отрезков
languages: [cpp]
tags: [cpp,classes]
checker: cmp_file
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
---

Роберт Вулпис Вульгатович занимается исследованием полугруппы отрезков. Множество состоит из отрезков на прямой с координатами концов в целочисленных точках, а операция определена как пересечение. Например, для отрезков [1,3] и [2,5] пересечением будет отрезок [2,3], для отрезков [-3,2] и [3,5] пересечением является пустое множество [], для отрезков [-3,2] и [2,5] пересечением является отрезок [2,2], содержащий ровно одну точку. У Роберта очень много гепотез, но ему сложно проверять их вычислениями на бумаге. Он обратился к вам за помощью. 

Смоделируйте с использованием инструмента классов языка C++ изучаемую полугруппу, удовлетворив следующим требованиям:
- объекты класса можно создавать с помощью конструктора с двумя параметрами - начало и конец отрезка;
- объекты класса можно создавать с помощью конструктора по умолчанию (без параметров) - получившийся отрезок должен представлять пустое множество;
- класс должен содержать метод ``bool contains(long long p) const``, возвращающий ``true``, если точка пренадлежит отрезку, и ``false`` в противном случае (пустое множество всегда возвращает ``false``);
- класс должен содержать метод ``bool empty() const``, который возвращает ``true`` только на пустом множестве;
- класс должен содержать метод ``long long count() const``, вычисляющий количество целых чисел, содержащихся в отрезке (для пустого отрезка - 0);
- класс должен содержать метод ``Segment const& print() const``, который выводит в стандартный поток ``std::cout`` данные об отрезке в формате ``[a,b]``, где a и b - начало и конец (пустое множество выводится как ``[]``, после закрывающейся скобки не должно выводиться никаких завершающих символов, как то пробел или перевод строки);
- класс должен содержать метод ``Segment& intersect(Segment const &oth)``, который изменяет состояние объекта, заменяя отрезок на пересечение текущего отрезка с отрезком ``oth``;
- предусмотрите защиту внутренних данных класса от случайного изменения;
- создайте глобальную функцию ``Segment intersect(Segment const &lha, Segment const &rha)``, которая возвращает в качестве результата **новый** объект класса Segment, который является пересечением ``lha`` и ``rha``, но не изменяет объекты, поданные в качестве параметров вызова.

**Важно!** Класс должен называться ``Segment``, а все методы должны строго следовать описанным выше сигнатурам! Ваш класс будет прикреплён к тестирующему коду, ошибки в имени класса или сигнатурах метода приведут к ошибкам компиляции.

### Формат входных данных

Входные и выходные данные тестирующая программа обрабатывает самостоятельно.
Необходимо отправить только код класса с необходимыми заголовочными файлами.

### Формат выходных данных

Входные и выходные данные тестирующая программа обрабатывает самостоятельно.
Необходимо отправить только код класса с необходимыми заголовочными файлами.

### Примеры
Примеры вызова класса из тестирующего кода:

```
Segment s; s.print().count(); 
--
[]0
```

```
std::cout << intersect(Segment(1,2),Segment(2,3)).print().count() << std::endl;
--
[2,2]1
```
