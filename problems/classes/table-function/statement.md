---
id: e761b748-2372-4c5f-b608-966bf45b6a2d
longname: Табличная функция
languages: [cpp]
tags: [cpp,classes]
checker: cmp_double_seq
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
---

Фёдор Михайлович Подсчитайло написал небольшой код для интерполяции значений табличной функции в промежуточных точках:
```
#include <utility>

using ArgVal = std::pair<double,double>;

double interpolate(ArgVal left, ArgVal right, double inner_point) {
    return (right.second - left.second) / (right.first - left.first) * (inner_point - left.first) + left.second;
}
```
Каждая точка является парой значений типа ``std::pair<double,double>``, где первое значение ``.first`` - аргумент функции, а ``.second`` - значение функции.

В процессе работы Фёдор столкнулся с проблемой: табличная функция для вычисления значения требует массив значений, таблицу в качестве одного из аргументов:
```
double table_function(double x, std::vector<ArgVal> const &table);
```
В таком виде ``table_function`` не может быть использована во многих стандартных алгоритмах C++, например в алгоритме ``std::transform``.

Преодолеть возникшие сложность можно с помощью механизма классов. Классы с перегруженным оператором круглых скобок ``operator()`` порождают объекты, которые могут быть использованы как функции, при этом такие объекты не ограничены только входными параметрами при вызове с круглыми скобками, но могут использовать внутренние поля в качестве контекста.

Напишите класс ``TableFunction`` с перегруженным оператором круглых скобок, который моделирует табличную функцию. При написании класса следует удовлетворить следующим требованиям:
- класс содержит ровно один конструктор, принимающий в качестве параметра вектор пар <аргумент,значение> ``TableFunction(std::vector<ArgVal> const &vec)``;
- класс содержит перегруженный оператор круглых скобок, принимающий ровно одно значение типа ``double`` ``double operator()(double x) const``;
- при написании интерполяции следует использовать функцию ``interpolate``, написанную Фёдором Михайловичем, чтобы избежать возможных проблем с ошибками округления при вычислениях;
- тестирующая программа гарантирует, что значения аргументов в векторе строго возрастающие;
- для аргументов, которые выходят за пределы покрытия таблицы следует использовать краевые значения функции.

***Важно!*** На проверку следует отправлять только код класса, он будет присоединён к тестирующей программе. Название класса и сигнатуры методов должны быть ровно такими, как они описаны в задании.

### Формат входных данных

Входные и выходные данные обрабатываются тестирующей программой. 

### Формат выходных данных

Входные и выходные данные обрабатываются тестирующей программой.

### Примеры

Пример кода, тестирующей программы, к которой будет присоединён ваш код:
```
TableFunction f(read_agr_val_vector());
std::vector<double> args = read_agr_vector();
std::vector<double> vals(args.size(),0);
std::transform(args.begin(),args.end(),vals.begin(),f);
for (auto d : vals)
    std::cout << d << " ";
```
