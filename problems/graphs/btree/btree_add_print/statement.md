---
id: 6e77beeb-4bde-4446-981f-fbebff52e617
longname: Функции add и print для двоичного дерева
tags: [graphs,binary,tree,btree]
checker: cmp_file
source_footer: footer.py
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
---

Реализуйте структуру данных "двоичное дерево". Для создайте класс 'Tree' по шаблону:

```
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class Tree:
    def __init__(self):
        self.root = None

    def add(self, data):
        #TODO
        pass

    def print(self):
        #TODO
        pass
```

Класс 'Node' вам также нужно написать в решении.

Здесь:
* data - данные, хранящиеся в узле,
* left - левый ребенок. None, если ребенка нет.
* right - правый ребенок. None, если ребенка нет.

Реализуйте методы работы с бинарным деревом: 
* insert(data)
    Добавляет узел со значением х в (под)дерево, корень которого tree.root != None.
    Бинарное дерево достраивается рекурсивным спуском по дереву; на каждом шаге спуска выбирается соотвествующая левая или правая ветка (в зависимости от того, меньше х или больше значения data, хранящегося в текущем узле дерева), пока не найдется место для вставки новой вершины (т.е ссылка на нужную ветвь равна None). Новая вершина добавляется как лист дерева, т.е. указатели на дочерние вершины left и right равны None. Если элемент уже существует в дереве, добавлять его не надо. Балансировка дерева не производится. 
* print() 
    Обходит дерево в глубину слева направо, печатая значения data, хранящиеся в узлах, через пробел. Перевод строки не ставит.
    Вызывает функцию печати левого поддерева, печатает значение в узле, вызывает функцию печати правого поддерева 

Никаких действий с деревом реализовывать НЕ нужно. Функции тестирования класса Tree будут автоматически дописаны ниже него в текст программы.
Проверить себя (не для посылки в систему) можно так:
Например, код
```
tree = Tree()
for x in [7, 3, 2, 1, 9, 5, 4, 6, 8]:
    tree.add(x)
tree.print()  # напечатает 1 2 3 4 5 6 7 8 9
```
