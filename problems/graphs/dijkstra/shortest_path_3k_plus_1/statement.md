---
id: e8e9354e-7ba9-403e-9a65-5e3f8bd7467f
longname: Путь минимального веса из 3k+1 ребер
tags: [graphs,dijkstra]
languages: [python]
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
---


Дан неориентированный взвешенный связный граф и несколько пар его вершин. Для каждой введенной пары вершин выведите минимальный по весу путь содержащий 3k+1 (т.е. 1, 4, 7, ...)  ребер, или -1, если такого пути нет.

Нужно построить вспомогательный граф, вершинами которого будут состояния (v,c), где v — номер текущей вершины, c = 0, 1 или 2 — остаток от деления количества ребер в пути на три. Любое ребро (u,v) исходного графа в этом новом графе превратится в шесть направленыx ребер ((u,0),(v,1)), ((v,0),(u,1)), ((u,1),(v,2)), ((v,1),(u,2)), ((u,2),(v,0)), ((v,2),(u,0)). После этого на вспомогательном графе надо с помощью алгоритма Дейкстры найти путь минимального веса из стартовой вершины с остатком 0 в конечную вершину, с остатком равным 1.

### Формат входных данных

На вход программе в первой строке подается два числа (через пробел): `n`, `m`. Число `n` (2 <= `n` <= 1000) - число вершин в графе, `m` (1 <= `m` <= 20000) - число ребер. В следующих `m` строках задаются ребра, по три числа в каждой строке - номера(из интервалла от 0 до n-1) соединенных вершин и положительный вес ребра. Дальше на вход передается одно число l, за ним следуют l строк по два числа задающих пары, между которыми необходимо найти пути.

### Формат выходных данных

Для каждой заданной пары вершин выведите в отдельной строке путь между ними длины 3k+1 (т.е. 1, 4, 7, ...)  минимального веса в виде списка вершин и -1 если такого пути нет.

### Примеры
```
-> 2 1
-> 0 1 81
-> 1
-> 0 1
--
<- 0 1
```

```
-> 4 3
-> 3 2 73
-> 2 0 31
-> 0 1 89
-> 2
-> 0 1
-> 0 3
--
<- 0 1
<- 0 2 0 2 3
```
