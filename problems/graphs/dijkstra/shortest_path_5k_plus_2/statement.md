---
id: 83ed15cb-88c5-4569-a4d6-979a167859a9
longname: Путь минимального веса из 5k+2 ребер
tags: [graphs,dijkstra]
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
---


Дан неориентированный взвешенный связный граф и несколько пар его вершин. Для каждой введенной пары вершин выведите минимальный по весу путь содержащий 5k+2 ребер, или -1, если такого пути нет.

Нужно построить вспомогательный граф, вершинами которого будут
состояния (v,c), где v — номер текущей вершины, c = 0, 1, 2, 3, 4 —
остаток от деления количества ребер в пути на пять. Любое ребро (u,v)
исходного графа в этом новом графе превратится в 10 направленый ребер
((u,0),(v,1)), ((v,0),(u,1)), ((u,1),(v,2)), ((v,1),(u,2)),
((u,2),(v,3)), ((v,2),(u,3)), ((u,3),(v,4)), ((v,3),(u,4)),
((u,4),(v,0)), ((v,4),(u,0)). После этого на вспомогательном графе
надо с помощью алгоритма Дейкстры найти путь минимального веса из
стартовой вершины с остатком 0 в конечную, с остатком равным 2.

### Формат входных данных

На вход программе в первой строке подается два числа (через пробел): `n`, `m`. Число `n` (2 <= `n` <= 1000) - число вершин в графе, `m` (1 <= `m` <= 20000) - число ребер. В следующих `m` строках задаются ребра, по три числа в каждой строке - номера(из интервалла от 0 до n-1) соединенных вершин и положительный вес ребра. Дальше на вход передается одно число k, за ним следуют k строк по два числа задающих пары, между которыми необходимо найти пути.

### Формат выходных данных

Для каждой заданной пары вершин выведите в отдельной строке путь между ними длины 5k+1 минимального веса в виде списка вершин и -1 если такого пути нет.

### Примеры
```
-> 2 1
-> 0 1 15
-> 1
-> 0 1
--
<- 0 1 0 1 0 1 0 1
```

```
-> 4 3
-> 3 1 12
-> 0 1 45
-> 2 1 90
-> 2
-> 0 1
-> 0 3
--
<- 0 1 3 1 3 1 3 1
<- 0 1 3
```
