---
id: 3147a541-3ffc-4193-8c92-29a194d79386
longname: Ремонт в Ханое
languages: [cpp]
tags: [recursion]
checker: cmp_yesno
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
---

Постановлением ЮНЕСКО оригинал Ханойской башни был подвергнут реставрации.
В связи с этим во время пользования головоломкой нельзя было перекладывать кольца с первого стержня сразу на третий и наоборот (но можно переложить диск с первого стержня на второй, а с него — на третий).
При каждом перемещении должно сохраняться правило о том, что нельзя класть диск большего размера на меньший.

Решите головоломку (переложите все кольца *с первого стержня на третий*) с учетом этих ограничений.

Для вас описана структура `Move` стремя полями типа `int`: `num` - номер диска, `from` - номер стержня, с которого вы его перемещаете, и `to` - номер стержня куда вы его перемещаете.

	struct Move{
	    int num;
	    int from;
	    int to;
	};

Вам необходимо написать функцию `hanoi_repair`, которая получает как параметр число дисков `N` (от 1 до 10), а на выходе выдаёт указатель на массив структур типа `Move`, который показывает последовательность корректных перемещений дисков для того, чтобы перенести башню с первого стержня на третий. Последним элементом вашего массива необходимо поставить структуру `Move` c полями, равными 5.

	Move* hanoi_repair(int N);


Нумерация колец начинается с 1 (самый маленький), а заканчивается `N` (самым большим). Номера стержней - 1, 2 и 3.

### Формат входных данных

Данные с клавиатуры считывать не нужно.

### Формат выходных данных

Выводить на экран ничего не нужно. Ваша функция должна вернуть адрес динамически выделенной памяти с массивом структур, содержащих ответ..

### Примеры

```
-> 1
-- 
<- Содержание массива структур: [{1, 1, 2}, {1, 2, 3}, {5, 5, 5}]
```

```
-> 2
--
<- Содержание массива структур: [{1, 1, 2}, {1, 2, 3}, {2, 1, 2}, {1, 3, 2}, {1, 2, 1}, {2, 2, 3}, {1, 1, 2}, {1, 2, 3}, {5, 5, 5}]
```

Для тестирования своей функции используйте следующий шаблон охватывающей программы (его посылать не нужно!):

	#include <iostream>

	struct Move{
	    int num;
	    int from;
	    int to;
	};

	Move* hanoi_repair(int N)  // FIXME: here should go your code
	{
		Move* moves = new Move[1] = {5, 5, 5};
		return moves;
	}

	bool check_move(int num, int from, int to, int N, int* mass)
	{
	    int i;
	    for (i = 0; i < num - 1; i++) //проверяем, что нет более лёгких там "куда"
	    {
		if (mass[i] == to) {
			return false;
		}
	    }
	    if ((from == 2) && (to == 3)) {
		    return false; //ремонт как бы
	    }
	    for (i = 0; i < num - 1; i++) //проверяем, что нет более лёгких там "откуда"
	    {
		if (mass[i] == from) {
			return false;
		}
	    }
	    return true;
	}

	int correct_check(int N, Move* arr)
	{
	    int mass[10];
	    int flag = 1;
	    long int i;
	    for(i = 0; i < N; i++){
		mass[i] = 1;
	    }
	    i = 0;
	    while (arr[i].from != 5){
		i++;
	    }
	    long int k = i;
	    if (k > 200000){
		flag = 0;
		return flag;
	    }
	    for (i = 0; i < k; i++){
		if (check_move(arr[i].num, arr[i].from, arr[i].to, N, mass)){
		    mass[arr[i].num- 1] = arr[i].to;
		}
		else {
		    flag = 0;
		    return flag;
		}
	    }
	    for (i = 0; i < N; i++){
		if (mass[i] != 3){
		    flag = 0;
		    return flag;
	       }
	    }
	    return flag;
	}

	int main()
	{
	    Move* arr_;
	    int i = 0;
	    int N_;
	    std::cin >> N_;
	    arr_ = hanoi_repair(N_); //функция студентов
	    if (correct_check(N_, arr_) == 1) {
		std::cout << "Yes";
	    }
	    else {
		std::cout << "No";
	    }
	    delete arr_;
	    return 0;
	}

