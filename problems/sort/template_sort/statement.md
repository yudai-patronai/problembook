---
id: 4f2edd56-7242-401e-9156-6970b5505cc9
longname: Шаблонная сортировка
languages: [cpp]
tags: [sort]
checker: cmp_file
source_header: header.cpp
source_footer: footer.cpp
time_limit: 2
real_time_limit: 2
max_vm_size: 64M
---


Напишите шаблонную функцию Sort, которая принимает на вход два итератора и функтор, и выполняет сортировку диапазона от первого итератора включительно до второго не включительно, используя функтор для сравнения. Функция должна корректно работать без третьего параметра, в этом случае следует использовать std::less. Также напишите функцию, которая принимает на вход указатель std::vector и функтор, и сортирует этот вектор (эта функция также должна называться Sort). Устойчивая сортировка не требуется. Алгоритм сортировки не должен иметь сложность больше, чем O(NlogN).

Гарантируется, что оба итератора удовлетворяют требованиям LegacyRandomAccessIterator, сортируемые объекты - требованиям DefaultConstructible, CopyConstructible, CopyAssignable и Destructible, а функтор - требованиям Compare. Использование заголовочного файла algorithm и стандартных контейнеров, хранящих элементы в отсортированном виде запрещено.

Не обязательно писать сортировку заново, можно взять написанную в прошлом семестре и адаптировать.

Для локального тестирования можно использовать следующий код:

<pre>
int main() {
    {
        std::vector < int32_t > a{4, 3, 2, 1};
        Sort(a.begin(), a.end());
        for (auto i: a) { std::cout << i << " "; }
        // 1 2 3 4
        std::cout << "\n";
    }
    {
        std::vector < int32_t > a{4, 3, 2, 1};
        Sort(&a);
        for (auto i: a) { std::cout << i << " "; }
        // 1 2 3 4
        std::cout << "\n";
    }
    {
        std::vector < int32_t > a{1, 2, 3, 4};
        Sort(a.begin(), a.end(), std::greater< int32_t >());
        for (auto i: a) { std::cout << i << " "; }
        // 4 3 2 1
        std::cout << "\n";
    }
}
</pre>

### Формат входных данных

Входных данных нет

### Формат выходных данных

Выходных данных нет
