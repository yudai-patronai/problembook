---
id: aa026ad9-8ada-49eb-bb95-0ebf2955e7d0
longname: Вычисление арифметического выражения в целых числах
languages: [cpp]
tags: [cpp,expression]
checker: cmp_file
time_limit: 1
real_time_limit: 1
max_vm_size: 64M
---
Фёдор Михайлович Подсчитайло устал вычислять арифметические примеры на калькуляторе, тем более из-за своей рассеянности он совершает ошибки в записи и ему приходится вводить их заново. Фёдор решил набирать выражения в виде строк в текстовом файле. Но для того, чтобы их вычислять необходима специальная программа.

Помогите Фёдору михайловичу, напишите программу, которая прочитает из входного потока данных строку, содержащую верное или неверное арифметическое выражение, в стандартный поток вывода запишет результат: число для верного выражения, строку ``ERROR`` для ошибочного выражения.

Арифметическое выражение на целых числа представляет из себя строку, состоящую из цифр ``0123456789``, символов операций ``-+*/`` и круглых скобок ``( )``. Другие символы не допускаются, cледует вывести ``ERROR``. Пробелы и переводы строк следует игнорировать.

Формально арифметическое выражение для разбора можно записать в форме Бэкуса-Наура (БНФ):
```
E ::= P + E | P - E #выражение состоит из сколь угодно длинной цепочки сложения и вычитания, пустое выражение ошибочно 
P ::= U * P | U / P #элемент суммы состоит из сколь угодно длинной цепочки перемножений и делений
U ::= - T | T #элемент произведения может содержать ведущий знак '-' - унарный минус
T ::= N | (E) #элементом произведения может быть верное выражение, взятое в скобки или число
N ::= DN | D #число - сколь угодно длинная последовательность цифр
D ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

Приведённая выше порождающая грамматика задаёт приоритет операций между сложением (вычитанием) и умножением (делением), но не отвечает порядку действий. Она допускает вычисления как слева направо, так и справа налево. Фёдор Михайлович представил грамматику в более удобном для рекурсивного разбора виде:
```
E ::= PS
S ::= +PS | -PS | <empty> #S может быть пустым
P ::= UM
M ::= *UM | /UM | <empty>
U ::= -T | T
T ::= N | (E)
N ::= D N | D
D ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```
Теперь порядок вычислений задан слева направо (левоассоциативные операции).

***Важно*** Программа может производить разбор и вычисления любым удобным способом, но приоритет операций и порядок вычислений должны быть соблюдены. Гарантируется, что при верном порядке вычислений все промежуточные результаты лежат в диапазоне ``[-2'147'483'648,2'247'483'647]``.

### Формат входных данных

Строка, состоящая из символов в кодировке ``ASCII``, возможно разделённых некоторым количеством пробелов. Гарантируется, что верно записанные целые числа лежат в диапазоне ``[-2'147'483'648,2'247'483'647]``.

### Формат выходных данных

Если строка - это верное арифметическое выражение, то вывести результат вычислений.
Если строка содержит ошибку, вывести ``ERROR``.

### Примеры

```
-> 2
--
<- 2
```

```
-> -2
--
<- -2
```

```
-> 2-
--
<- ERROR
```

```
-> ()
--
<- ERROR
```

```
-> 2 * 3 - 3 * 2
--
<- 0
```

```
-> 2x + 3 * (5 - 1)
--
<- ERROR
```

```
-> (86 / 3 - 3 * 9) / (121 / 11 - 100 / 5 / 2) + -(2147483647 / 2 / (128 + 512) - 10 * 10 * 10 * 10 * 10 * 10) / 121 / 3 - 1867
--
<- -3733
```
  
